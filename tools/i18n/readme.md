
## 前端国际化经验分享与自动维护程序开发实践

### 前端项目多语言支持需要关注或者会遇到哪些问题？

**样式兼容问题**

不同语言翻译文案长短不一，需要考虑显示空间、换行等问题，特别是要考虑复杂的交互、紧凑布局对不同语言的文字显示适配支持；通常的优化方案有以下两点：

* 样式书写遵循 _`无宽度准则`_ ，在界面布局的时候充分利用block水平元素的宽度自动填充特性，不要写死宽度。针对UI还原度的宽度对齐问题，应优先使用padding对齐两边留白间隙。
* 使用HTML元素的lang属性 + CSS属性选择器`[lang="xx"]`定制区分样式，以实现不同语言的适配。

**开发效率问题**

开发效率问题主要体现在两方面：

* 迭代过程中每书写一句文案内容，都需要同时将其它N种语言的翻译结果文案添加到对应的文件中，翻译动作频繁、代码文件修改数量成倍增加，长期累计耗费人力不可忽视；
* 多人开发合作问题，大家几乎都会在同一个迭代中改到语言文件，比正常功能开发冲突概率明显要高，提交冲突不可避免，效率变低同时增加协作成本；

**持续维护问题**

随项目持续迭代，大量文案增加删除或者修改更新，显而易见非常耗费人工检查核对与翻译成本。

**翻译工作量问题（针对已经具有一定规模的项目）**

文案数量轻易就上千，如果逐个源码文件手动修改并同步记录，对代码行超过10万的项目，工作量是无法想像的。不仅仅需要逐个文案手动修改为i18n函数调用，修改过程中还需要关注以下细节：

* 不同上下文的替换模式不同，如js字符串、js模板字符串中包含变量或者长内容（多行文本）中的换行转义、JSX属性、JSX文本节点，这些不同语法上下文中的文案替换处理格式各不相同，需要考虑的文案内容转义处理也不相同，人工处理大量的内容难免会出错；
* 文案中间包含变量表达式，手工修改效率低下，对于前端项目而言，模板字符串、JSX文本节点中都可能大量出现此类场景；

**翻译相关问题**

除以上4点，一般还会遇到以下细节问题：

* 特殊语种具有的问题，如英文特有的单复数问题处理，需要结合特定的语法，这也大大增加人工翻译的成本；
* 翻译冲突问题，针对较大的项目，短文案的大量重复出现是很常见的，但同一个文案在不同业务中可能表示不同含义（特别是中文），因此会对应不同的其它语言翻译；
* 前后端语言一致问题；

### 自动维护程序开发分享

i18n自动化处理程序解决了开发效率和持续维护的问题，**开发过程中书写文案无需关心多语言问题（不用事先书写多语言翻译函数），完成功能模块后，简单调用处理脚本即可完成代码的翻译替换工作**。同时，自动化处理程序提供了对语言资源文件中废弃文案和未记录文案的检索支持，让维护工作变得简单高效。

#### 使用方法

本处理程序基于react项目，如需要支持其它框架项目，需对正则匹配模式稍加修改以及安装对应框架的i18next库。

**第一步: 引入i18next、配置脚本命令**

准备环境：如果未安装`ts-node`，需要先安装:

```
npm install -D ts-node
```

检查`tsconfig.json`文件是否有以下配置项：

```
{
  "compilerOptions": {
    "module": "ESNext",
  },
  "ts-node": {
    "compilerOptions": {
      "module": "CommonJS"
    }
  }
}
```

如果没有，请补上遗漏的配置项。

__注：如果以上typescript相关的配置项与你的项目冲突，修改后运行不起来，可以修改`config.ts`文件中的`resource`属性，将动态导入替换为文件头部静态导入声明，并修改其它脚本文件中对resource的引用。__

安装i18n包：

```
npm install i18next react-i18next
```

创建i18n语言资源文件：

在`src/i18n/locales`目录（可根据你的项目偏好设置为其它目录）下新建语言资源文件`en.ts`、`th.ts`、`zh.ts`，默认内容如下：
```
export default {
  translation: {}
}
```
新建`index.ts`导出所有资源文件：
```
import en from './en';
import zh from './zh';
import th from './th';

export default {
  en,
  zh,
  th,
};
```

在`src/i18n`目录下新建`index.ts`文件，内容参见`template.ts.txt`示例，该文件负责实例化i18n对象，同时使用export导出要预设的t函数名称，例如：
```
export const T = i18n.t; // 导出t函数名称为 'T'
```

__注: 这一步export导出的t函数名称必须与后面即将介绍到的`config.ts`配置文件中的`tFuncName`配置项一致__

在`package.json`中添加脚本命令：

```
  "update-i18n": "ts-node ./script/i18n/update-i18n.ts",
  "test-i18n": "ts-node ./script/i18n/update-i18n.ts --test",
```
__注: 路径需修改为实际的脚本存放路径。__

**第二步: 修改配置文件**

找到`config.ts`文件:

1. 替换 `resource`导入为自己项目中实际的资源文件位置，一般指定英文版资源位置即可。(该资源文件导出一个JSON对象，用于在程序中作为翻译文案记录列表的对比源)
2. 根据各个配置选项的注释说明，修改config对象配置以适合你的项目，一般需要修改的配置项有：

** `tFuncName` 导出`i18n.t`函数的别名
** `tFuncImportPath` 须修改为你的项目中导出`i18n.t`函数的文件的import路径
** `sourceDir` 需要扫描的项目源码目录，可以指定多个（数组）
** `extensions` 指定需要扫描的文件扩展名类型（数组）
** `excludes` 指定需要跳过的路径（数组，使用路径包含验证）

**第三步: 源码扫描替换&翻译**

<span id="step3">运行命令</span>
```
npm run update-i18n
```

在脚本同目录下找到`results.json`文件，将文件中的内容粘贴到在线翻译网站：[https://translate.i18next.com/]() ，翻译为目标语言后，将内容合并回语言资源文件中即完成。

最后，启动项目本地服务，检查启动是否正常、各页面显示文案是否正常，手工核对git changes并提交即可。


### 原理介绍

结合代码讲解（略）。

大致原理：

使用正则配置（提供正则定制化匹配扩展）+ 上下文语境标注完成对源码不同语法环境中的文案替换。

1. 精准提取文案

正则书写过程中添加文案占位符约束，程序在初始化构造正则时，自动将占位符替换为带有命名分组的子正则串，通过命名分组即可精准获取命中的文案内容。

要精准命中文案内容，在书写正则时特别需要对转义字符进行识别和修改匹配规则，典型的场景有：

* 表单控件限制特殊字符输入的提示内容
* 文案上下出现正则表达式

这两种场景很容易导致自动处理程序中构造的正则产生错误的匹配结果，需要在书写正则时包含**转义识别模式**（例如，`(?:[^'\n\\]|\\.)*`可以匹配单引号字符串内的所有被转义的单引号，而不是将之识别为“字符串结束”。）以及**正/反向(肯定/否定)预查**（例如，`(?=</?\w+>|<\w+\s?/?>|</?>|<\w+[\s\n]+\w+[=\s])`可以预判一串内容后接的是否是JSX标签，此示例为正向肯定预查，可以匹配以下示例格式：`<>`、`</>`、`</div>` 、`<br />`、`<a href=`、`<Checkbox checked `）。

转义识别

2. 精准的替换文案

一个构造完成的正则只能匹配一个特定上下文语境类型中的文案，语境标识告诉程序应该如何处理转义问题，以保证替换结果能正则包含特殊字符并且不丢失字符（通常是反斜杠后的字符或其自身）。

3. 文案增量收集与整理

每次运行都扫描整个项目源码，将收集的结果集与语言资源文件中已记录的文案（通常取英文资源文件）进行diff，即可输出新增以及废弃的文案列表。


### 手工辅助查找未翻译内容

自动翻译程序不能100%覆盖所有未翻译的中文文案，并且部分文案可能因误用参与了业务逻辑判断，这样的文案是不能翻译的，翻译程序已经作了识别并跳过处理，不被翻译的内容有以下几种：

+ 埋点事件名称，格式为`event_name: 'xxx'`
+ React Key，即JSX标签中的key属性，格式为`key="xxx"`
+ 部分表单控制的value属性，格式为`value="xxx"`或`defaultValue="xxx"`或`value: 'xxx'`，这些值被视为常量枚举值，不翻译
+ 大写开头的变量赋值，大写的变量也被视为常量
+ 字符串查找、分割之类的方法调用参数，例如`indexOf`、`endsWith`、`split`等等

**如何手动查找处理可能错误使用的中文文案以及未翻译的文案**

通过vscode全局搜索功能查找以下正则（注意不要启用全字匹配）

查找未被函数调用参数包裹的中文
```
(?<!event_name:)[^\(]'[^']*[\u4E00-\u9FA5]+[^']*'
```

查找非法使用中文判断的语句
```
(indexOf|includes|startsWith|endsWith)\('\w*[\u4E00-\u9FA5]+|== '[\w\-\\/]*[\u4E00-\u9FA5]+
```

查找“中文内容替换”相关的调用
```
replace\([\w\-\\/']+[\u4E00-\u9FA5]+[^/']*['/]
```

查找字符串字面量的特殊用法，例如 '一二三四五六日'.split('.')
```
'[^']*[\u4E00-\u9FA5]+[^']*'\.
```

查找包含表达式的模板字符串中文、数组中的中文内容
```
\}'[\u4E00-\u9FA5]+|[\u4E00-\u9FA5]+(?:\$?\{)|(?:,|\n)\s+'[\u4E00-\u9FA5]+'
```

### FAQ

Q: 后续写代码的时候手写T函数或者不写会有什么区别吗？
A: 可以自由选择，翻译程序运行处理后最终结果是一样的。另外，需要注意的是，**不要手写包含表达式作为key的T函数**，例如`T(isEdit ? '编辑' : '新增')`，这将导致翻译处理完后变成`T(isEdit ? T('编辑') : T('新增'))`，最终有可能导致文案错误。

Q: 手工翻译除了替换源码内容为i18n.t函数调用外，还需要手动往语言资源文件里添加key吗?
A: 不需要，有任何翻译变动，可以在最后提交之前手动运行一次update-i18n程序即可输出翻译的内容变动结果。

Q: 后续迭代如何快速更新同步翻译？
A: 详见[使用方法:第三步](#step3)，重复该步骤即可。
